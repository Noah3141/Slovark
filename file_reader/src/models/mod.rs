
// <page>
//     <title>рейка</title>
//     <ns>0</ns>
//     <id>5861296</id>
//     <revision>
//       <id>79677807</id>
//       <parentid>72033732</parentid>
//       <timestamp>2024-06-02T12:28:59Z</timestamp>
//       <contributor>
//         <username>WingerBot</username>
//         <id>2024159</id>
//       </contributor>
//       <minor />
//       <comment>replace &lt;* {{audio|uk|Uk-рейка.ogg|Audio}}&gt; with &lt;* {{audio|uk|Uk-рейка.ogg}}&gt; (clean up audio captions)</comment>
//       <origin>79677807</origin>
//       <model>wikitext</model>
//       <format>text/x-wiki</format>
//       <text bytes="651" sha1="lvkabzoq3q610nmbnv1mh5dk8vlz4cz" xml:space="preserve">
//==Russian==

// ===Etymology===
// From {{bor|ru|pl|reja}} + {{m|ru|-ка}}, from {{der|ru|nl|ra}}.

// ===Pronunciation===
// * {{ru-IPA|ре́йка}}

// ===Noun===
// {{ru-noun+|ре́йка|*}}

// # [[lath]]; strip of wood
// # measuring rod

// ====Declension====
// {{ru-noun-table|ре́йка|*}}

// ===References===
// * {{R:ru:Vasmer}}

// ==Ukrainian==

// ===Etymology===
// Per Vasmer, of {{unk|uk|title=unclear}} origin.

// ===Pronunciation===
// * {{uk-IPA|ре́йка}}
// * {{audio|uk|Uk-рейка.ogg}}

// ===Noun===
// {{uk-noun|ре́йка&lt;*&gt;}}

// # [[rail]]
// # [[slat]]
// # [[measuring rod]]

// ====Declension====
// {{uk-ndecl|ре́йка&lt;*&gt;}}

// ===References===
// * {{R:ru:Vasmer|рейка}}</text>
//       <sha1>lvkabzoq3q610nmbnv1mh5dk8vlz4cz</sha1>
//     </revision>
//   </page>
// ===================================================
// <page>
//     <title>заслонка</title>
//     <ns>0</ns>
//     <id>5861317</id>
//     <revision>
//       <id>66948787</id>
//       <parentid>50660824</parentid>
//       <timestamp>2022-05-15T06:42:08Z</timestamp>
//       <contributor>
//         <username>WingerBot</username>
//         <id>2024159</id>
//       </contributor>
//       <minor />
//       <comment>use {{af}} in place of {{prefix}}/{{suffix}}/{{affix}} etc.; move {{wikipedia}} lines to top of etym section (automatic + manually assisted)</comment>
//       <origin>66948787</origin>
//       <model>wikitext</model>
//       <format>text/x-wiki</format>
//       <text bytes="271" sha1="501hgbengdvt9yfufhci8wkwe1k1k4g" xml:space="preserve">==Russian==

// ===Etymology===
// {{af|ru|заслони́ть|-ка}}

// ===Pronunciation===
// * {{ru-IPA|засло́нка}}

// ===Noun===
// {{ru-noun+|засло́нка|*}}

// # [[flap]], [[valve]], [[shutter]], [[screen]]

// ====Declension====
// {{ru-noun-table|засло́нка|*}}</text>
//       <sha1>501hgbengdvt9yfufhci8wkwe1k1k4g</sha1>
//     </revision>
//   </page>
// ===================================================
// <page>
//     <title>эскадренный броненосец</title>
//     <ns>0</ns>
//     <id>5863801</id>
//     <revision>
//       <id>65028079</id>
//       <parentid>59641848</parentid>
//       <timestamp>2021-12-23T08:44:52Z</timestamp>
//       <contributor>
//         <username>WingerBot</username>
//         <id>2024159</id>
//       </contributor>
//       <minor />
//       <comment>Convert synonyms in Russian subsection 6 to inline synonyms in subsection 4 based on synonyms with only one definition</comment>
//       <origin>65028079</origin>
//       <model>wikitext</model>
//       <format>text/x-wiki</format>
//       <text bytes="663" sha1="98etnw21xj9sq3e7holgx22j4r3gyag" xml:space="preserve">==Russian==
// {{wikipedia|lang=ru}}
// [[File:Borodino1904Kronshtadt.jpg|thumb|эскадренный броненосец «Бородино»]]

// ===Etymology===
// {{calque|ru|fr|cuirassé d'escadre}}.

// ===Pronunciation===
// * {{ru-IPA|эска́дренный бронено́сец}}

// ===Noun===
// {{ru-noun+|[[эска́дренный]]|+|_|[[бронено́сец]]|*}}

// # {{lb|ru|historical|nautical}} late 19th or early 20th century [[pre-dreadnought]] [[battleship]] designed to operate as part of a [[squadron]]
// #:\n{{s\nyn|ru|додредно́ут}}

// ====Declension====
// {{ru-noun-table|эска́дренный|+|_|бронено́сец|*}}

// {{topics|ru|Warships}}</text>
//       <sha1>98etnw21xj9sq3e7holgx22j4r3gyag</sha1>
//     </revision>
//   </page>
// ===================================================
// <page>
//     <title>дредноут</title>
//     <ns>0</ns>
//     <id>5863943</id>
//     <revision>
//       <id>65052527</id>
//       <parentid>59635791</parentid>
//       <timestamp>2021-12-26T23:59:35Z</timestamp>
//       <contributor>
//         <username>WingerBot</username>
//         <id>2024159</id>
//       </contributor>
//       <minor />
//       <comment>use {{syn}}/{{ant}}/{{bor+}}/{{inh+}}/{{alt}} for Russian lemmas; misc cleanups (manually assisted)</comment>
//       <origin>65052527</origin>
//       <model>wikitext</model>
//       <format>text/x-wiki</format>
//       <text bytes="487" sha1="qgssaxo1inm44s97yw7k6os8hgnkjdc" xml:space="preserve">==Russian==
// {{wikipedia|lang=ru}}
// [[File:HMS Dreadnought 1906 H61017.jpg|thumb|Дредноут]]

// ===Etymology===
// {{bor+|ru|en|dreadnought}}.

// ===Pronunciation===
// * {{ru-IPA|дредно́ут}}

// ===Noun===
// {{ru-noun+|дредно́ут}}

// # {{lb|ru|historical|nautical}} [[dreadnought]]
// # {{lb|ru|music}} Dreadnought [[guitar]]

// ====Declension====
// {{ru-noun-table|дредно́ут}}

// ====Related terms====
// * {{l|ru|додредно́ут}}

// {{topics|ru|Musical instruments|Warships}}</text>
//       <sha1>qgssaxo1inm44s97yw7k6os8hgnkjdc</sha1>
//     </revision>
//   </page>
#[derive(Debug)]
pub enum PoS {
    Noun,
    Verb,
    Adjective,
}

#[derive(Debug)]
/// Faithful parsing of the WikiText strings in a page. Holds verbs, nouns, and adjective entries alike
pub struct WikiTextPage {
    pub page_id: u64,
    pub pos: PoS,
    pub plain_word: String,
    pub accented_word: String,
    pub table: String,
    pub etymology:Option<String>,
    pub related_terms: String
}

#[derive(Debug)]
pub enum WikiTextPageInitError {
    MissingCorePiece(String),
    MissingExtraPiece(String),
    NotADictionaryPage(String),
    UnimplementedPOSFound(String),
    NotASubstantiveWord(String),
    InflectedFormPage,
    UndeclinableNoun,
}

type InitError = WikiTextPageInitError;

impl WikiTextPage {
    fn test() {
        Self::find_accented_word(r#"""=======================================================start

<page>
    <title>полседьмого</title>
    <ns>0</ns>
    <id>5036007</id>
    <revision>
      <id>66991125</id>
      <parentid>51816945</parentid>
      <timestamp>2022-05-15T09:22:07Z</timestamp>
      <contributor>
        <username>WingerBot</username>
        <id>2024159</id>
      </contributor>
      <minor />
      <comment>use {{af}} in place of {{prefix}}/{{suffix}}/{{affix}} etc.; move {{wikipedia}} lines to top of etym section (automatic + manually assisted)</comment>
      <origin>66991125</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="512" sha1="k4unqvyy96azadadhxm08yjloz8lrpk" xml:space="preserve">==Russian==

===Etymology===
{{af|ru|пол-|седьмо́й|t1=[[half]]|t2=[[seventh]]}}, with {{m|ru|седьмо́й}} in the genitive case, as with other words prefixed with {{m|ru|пол-}}. Compare {{cog|de|halb sieben||half past six|lit=half seven}}.

===Pronunciation===
* {{ru-IPA|по̀лседьмо́го}}

===Noun===
{{ru-noun|полседьмо́го|tr=polsedʹmóvo|n-in|-}}

# {{lb|ru|colloquial}} [[half past]] [[six]], [[six-thirty]] {{gloss|hour of the day}}

====Declension====
Invariable.</text>
      <sha1>k4unqvyy96azadadhxm08yjloz8lrpk</sha1>
    </revision>
  </page>

=======================================================end"""#).expect("to find it");
    }

    /// Return a `Self` if the block expresses a head (infinitive, dictionary form noun, etc.)
    /// Else return a string containing the oblique plain_word in question
    pub fn parse_russian(page: &str) -> Result<Self, InitError> {
        Self::test();
        let page_id = Self::find_id(&page[..])?;
        let plain_word = Self::find_plain_word(&page[..])?;
        if plain_word.chars().count() < 3 { return Err(InitError::NotASubstantiveWord("Single letter word".to_string())) }
        
        // Now parse down the Russian section only via detecting any OTHER sections
        let russian_start = page.find("==Russian==").expect("No russian section found!");
        let russian_onward = &page[russian_start..];
        let section_headers = [
            "==Ukrainian==",
            "==Serbo-Croatian==",
            "==Tabasaran==",
            "==Udmurt==",
            "==Southern Altai==",
            "==Tatar==",
            "==Tundra Nenets==",
            "==Tuvan==",
            "==Wakhi==",
            "==Western Mari==",
            "==Ubykh==",
            "==Yakut==",
        ];
        
        let any_section_switch = section_headers.iter()
            .filter_map(|&header| russian_onward.find(header).map(|i| i + russian_start))
            .min()
            .unwrap_or(page.len());
        let russian_section = &page[russian_start..any_section_switch];
        

        println!("\x1b[31m&&&&&&&&&start\n{russian_section}&&&&&&&&end\n\x1b[0m");

        let pos = Self::determine_pos(russian_section)?;
        let accented_word = Self::find_accented_word(russian_section)?;
        let table = Self::find_table(russian_section, &pos)?;
        let etymology = Self::find_etymology(russian_section)?;
        let related_terms = Self::find_related_terms(russian_section)?;

        Ok(Self {
            plain_word,
            accented_word,
            etymology,
            page_id,
            pos,
            related_terms,
            table
        })
    }

    pub fn pronunciation(self) -> String { format!("{{{{ru-IPA|{}}}}}", self.accented_word) }


    const ID_START: &str = "<id>";
    const ID_END: &str = "</id>";

    fn find_id(page: &str) -> Result<u64, InitError> {
        let start: usize = page.find(Self::ID_START).ok_or(InitError::MissingCorePiece("No start id tag found.".to_string()))? + Self::ID_START.len();
        let end: usize = page.find(Self::ID_END).ok_or(InitError::MissingCorePiece("No end id tag found.".to_string()))?;
        let id: u64 = page[start..end].parse::<u64>().map_err(|_| InitError::MissingCorePiece("Failed to parse as int.".to_string()))?;
        Ok(id)
    }

    const TITLE_START: &str = "<title>";
    const TITLE_END: &str = "</title>";

    fn find_plain_word(page: &str) -> Result<String, InitError> {
        let start = page.find(Self::TITLE_START).ok_or(InitError::MissingCorePiece("No start title tag found.".to_string()))? + Self::TITLE_START.len();
        let end = page.find(Self::TITLE_END).ok_or(InitError::MissingCorePiece("No end title tag found.".to_string()))?;
        let title = page[start..end].to_string();

        if title.starts_with("Wiktionary:") 
        || title.starts_with("User:") { 
            return Err(InitError::NotADictionaryPage(page.to_string())) 
        }
        Ok(title)
    }

    fn find_accented_word(russian_section: &str) -> Result<String, InitError> { // {{ru-IPA|эска́дренный бронено́сец}}
        let pronunciation_start: usize = russian_section.find("===Pronunciation===").ok_or(InitError::MissingExtraPiece("No pronunciation section!".to_string()))?;
        let pronunciation: &str = &russian_section[pronunciation_start..];
        let start: usize = pronunciation.find("{{").ok_or(InitError::MissingCorePiece("Open bracket to pronunciation missing!".to_string()))?;
        let end: usize = pronunciation.find("}}").ok_or(InitError::MissingCorePiece("Closing bracket to pronunciation missing!".to_string()))?;
        Ok( pronunciation[start..end + 2].to_string() )
    }

    fn find_table(russian_section: &str, pos: &PoS) -> Result<String, InitError> {
        
        let result = match pos {
            PoS::Noun => russian_section.find("====Declension====").ok_or(InitError::MissingExtraPiece("No declension section for noun!".to_string())),
            PoS::Verb => russian_section.find("====Conjugation====").ok_or(InitError::MissingExtraPiece("No conjugation section for verb!".to_string())),
            PoS::Adjective => russian_section.find("====Declension====").ok_or(InitError::MissingExtraPiece("No declension section for adj!".to_string())),
        };

        match result {
            Err(e) => {
                if russian_section.contains("inflection of|ru|") {
                    return Err(InitError::InflectedFormPage)
                } else {
                    return Err(e)
                }
            },
            Ok(table_start) => {
                let subsection: &str = &russian_section[table_start..];
                let start: usize = subsection.find("{{").ok_or({
                    if subsection.contains("Invariable") { InitError::UndeclinableNoun }
                    else { InitError::MissingCorePiece(format!("Open bracket to table missing!\n{subsection}\n\n")) }
                })?;
                let end: usize = subsection.find("}}").ok_or(InitError::MissingCorePiece("Closing bracket to table missing!".to_string()))?;
                Ok( subsection[start..end + 2].to_string() )
            },
        }
    }

    fn determine_pos(russian_section: &str) -> Result<PoS, InitError> {
        if let Some(find) = russian_section.find("===Noun===") { return Ok(PoS::Noun)};
        if let Some(find) = russian_section.find("===Verb===") { return Ok(PoS::Verb)};
        if let Some(find) = russian_section.find("===Adjective===") { return Ok(PoS::Adjective)};
        
        Err(InitError::UnimplementedPOSFound(String::from("No POS determinable! Probably an adverb or somethin, better get on that")))
    }

    fn find_etymology(russian_section: &str) -> Result<Option<String>, InitError> {
        let etymology_start = russian_section.find("===Etymology===");
        match etymology_start {
            None => Ok(None),
            Some(start) => {
                let etymology: &str = &russian_section[start..];
                let start: usize = etymology.find("{{").ok_or(InitError::MissingExtraPiece("Open bracket to etymology missing!".to_string()))?;
                let end: usize = etymology.find("}}").ok_or(InitError::MissingExtraPiece("Closing bracket to etymology missing!".to_string()))?;
                Ok( Some( etymology[start..end + 2].to_string() ) )
            }
        }
    }

    fn find_related_terms(russian_section: &str) -> Result<String, InitError> {
        let related_terms_start: usize = russian_section.find("====Related terms====").ok_or(InitError::MissingExtraPiece("No related terms section!".to_string()))?;
        let related_terms: &str = &russian_section[related_terms_start..];
        let start: usize = related_terms.find("{{").ok_or(InitError::MissingExtraPiece("Open bracket to related terms missing!".to_string()))?;
        let end: usize = related_terms.find("}}").ok_or(InitError::MissingExtraPiece("Closing bracket to related terms missing!".to_string()))?;
        Ok( related_terms[start..end + 2].to_string() )
    }



}